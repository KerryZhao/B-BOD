<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create Client Info List
clientInfo = ds_list_create();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create Buffers
connectBuffer = buffer_create(256, buffer_grow, 1);
pingBuffer = buffer_create(2, buffer_fast, 1);
readyBuffer = buffer_create(1, buffer_fast, 1);
updateBuffer = buffer_create(26, buffer_fixed, 1);
shootBuffer = buffer_create(17, buffer_fixed, 1);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>611</id>
        <kind>6</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>updateStepTime</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>room_speed/10</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Send connection message to server

//Create Socket
socketID = network_create_socket( network_socket_udp );

//Get ip and name
for(var i=0;i&lt;instance_number(obj_textBox);i++){
    var textBox = instance_find(obj_textBox, i);
    if(textBox.isIP)
        server = textBox.text;
    else
        name = textBox.text;
}

ready = false;
state = LOBBY;
clientNum = 0;

// Send connect message
buffer_seek(connectBuffer, buffer_seek_start, 0);
buffer_write(connectBuffer, buffer_u8, CONNECT);
buffer_write(connectBuffer, buffer_string, name);
result = network_send_udp(socketID, server, PORT, connectBuffer, buffer_tell(connectBuffer));

if(result&lt;0){
    obj_buttonMJoin.disabled = false;
    show_message_async("Could not send message to server!");
    instance_destroy();
}
else{
    //Start alarm to check for server connection
    alarm[1] = room_speed*PING_TIMEOUT;
    connected = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Destroy DS and Buffers
ds_list_destroy(clientInfo);
network_destroy(socketID);
buffer_delete(connectBuffer);
buffer_delete(pingBuffer);
buffer_delete(readyBuffer);
buffer_delete(updateBuffer);
buffer_delete(shootBuffer);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Send Updates to Server holding client control info

buffer_seek(updateBuffer, buffer_seek_start, 0);
buffer_write(updateBuffer, buffer_u8, UPDATE);

if(!instance_exists(player)){
    buffer_write(updateBuffer, buffer_f32, 0);
    buffer_write(updateBuffer, buffer_bool, false);
}
else{
    //Write the player info
    var move;
    var jetpack;
    with(player){
        if(gamepadSlot!=-1)
            move = gamepad_axis_value(gamepadSlot, moveAxis);
        else{
            var left = false;
            var right = false;
            for(var i=0;i&lt;array_length_1d(keyLeftButtons) &amp;&amp; !left;i++)
                if(keyboard_check(keyLeftButtons[i]))
                    left = true;
            for(var i=0;i&lt;array_length_1d(keyRightButtons) &amp;&amp; !right;i++)
                if(keyboard_check(keyRightButtons[i]))
                    right = true;
            move = right*1+left*-1;
        }
        jetpack = false;
        if(gamepadSlot==-1){
            for(var i=0;i&lt;array_length_1d(keyJetButtons) &amp;&amp; fuel&gt;0 &amp;&amp; !jetpackUsed;i++)
                if(keyboard_check(keyJetButtons[i]))
                    jetpack = true;
        }
        else{
            for(var i=0;i&lt;array_length_1d(jetButtons) &amp;&amp; fuel&gt;0 &amp;&amp; !jetpackUsed;i++)
                if(gamepad_button_check(gamepadSlot, jetButtons[i]))
                    jetpack = true;
        }
    }
    buffer_write(updateBuffer, buffer_f32, move);
    buffer_write(updateBuffer, buffer_bool, jetpack);
}

//Send the data to the server
network_send_udp(socketID, server, PORT, updateBuffer, buffer_tell(updateBuffer));

//Update again &amp; again &amp; again...
if(state==GAME)
    alarm[3] = updateStepTime;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Spawn the Player
player = instance_create(playerX, playerY, obj_playerClient);
player.controller = obj_gamepadControl.controller;
player.name = name;
player.num = clientNum+1;
state = GAME;
dead = false;

//Start updating the server
alarm[3] = updateStepTime;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>612</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if_variable</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>connected</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>false</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Disconnect
obj_buttonMJoin.disabled = false;
show_message_async("Server did not respond!");
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>421</id>
        <kind>3</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Start ping server
alarm[0] = room_speed;
pingFail = 0;
ping = true;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>224</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_another_room</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>11</kind>
            <room>rm_lobby</room>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Ping clients to make sure they are still there.

//Check if still connected
if(!connected)
    exit;
    
//Check for no response and timeout
if(!ping){
    if(++pingFail&gt;=PING_TIMEOUT){
        state = NONE;
        show_message_async("You have disconnected from the server!");
        connected = false;
        instance_destroy();
        room_goto(rm_mainMenu);
        exit;
    }
}

//Set ping variables
ping = false;

//Send Ping message to server
buffer_seek(pingBuffer, buffer_seek_start, 0);
buffer_write(pingBuffer, buffer_u8, PING );
buffer_write(pingBuffer, buffer_u8, 0 );
network_send_udp(socketID, server, PORT, pingBuffer, buffer_tell(pingBuffer));
alarm[0] = room_speed;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle Ping from Server

// Make sure it is data from the correct server
if(async_load [? "type"]!=network_type_data || async_load[? "ip"]!=server)
    exit;

// Inital Connection test
connected = true;
if(alarm[1]&gt;1)
    alarm[1] = 1;
    
// Get Type of message
buffer_seek(async_load[? "buffer"], buffer_seek_start,0);
messageType = buffer_read(async_load[? "buffer"], buffer_u8);
    
// Determine the type of message
switch(messageType){
    case PING:
        //Check if pinging or being pinged
        if(buffer_read(async_load[? "buffer"], buffer_u8)==0){
            //Reply to ping
            buffer_seek(pingBuffer, buffer_seek_start, 0);
            buffer_write(pingBuffer, buffer_u8, PING );
            buffer_write(pingBuffer, buffer_u8, 1 );
            network_send_udp(socketID, server, PORT, pingBuffer, buffer_tell(pingBuffer));
        }
        else{
            //Update ping values
            ping = true;
            pingFail = 0;
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle update of client list
switch(messageType){
        case CONNECT:
            // Get the client current client list
            show_debug_message("CONNECT MESSAGE");
            ds_list_clear(clientInfo);
            var numClients = buffer_read(async_load[? "buffer"], buffer_u8);
            for(var i=0;i&lt;numClients;i++)
                ds_list_add(clientInfo, buffer_read(async_load[? "buffer"], buffer_string));
            clientNum = buffer_read(async_load[? "buffer"], buffer_u8);
            break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle Messages in LOBBY
if(state==LOBBY){
    switch(messageType){
        case READY:
            ready = !ready;
            if(instance_number(obj_buttonMReady)&gt;0){
                if(ready)
                    obj_buttonMReady.buttonText = "Unready";
                else
                    obj_buttonMReady.buttonText = "Ready";
            }
            break;
            
        case START:
            room_goto(rm_mapSelect);
            break;
        
        case SPAWN:
            //Get goto room and save spawn point
            room_goto(buffer_read(async_load[? "buffer"], buffer_u32));
            playerX = buffer_read(async_load[? "buffer"], buffer_u16);
            playerY = buffer_read(async_load[? "buffer"], buffer_u16);
            alarm[2] = 1;
            break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle Messages in GAME
if(state==GAME){
    switch(messageType){
        case UPDATE:
        
            //Handle getting items info
            var count = buffer_read(async_load[? "buffer"], buffer_u8);
            //Update current items
            for(var i=0;i&lt;instance_number(obj_item) &amp;&amp; i&lt;count;i++){
                var item = instance_find(obj_item, i);
                item.newX = buffer_read(async_load[? "buffer"], buffer_f32);
                item.newY = buffer_read(async_load[? "buffer"], buffer_f32);
                item.phy_speed_y = buffer_read(async_load[? "buffer"], buffer_f32);
                item.trap = buffer_read(async_load[? "buffer"], buffer_bool);
                item.station = buffer_read(async_load[? "buffer"], buffer_u8);
                item.type = buffer_read(async_load[? "buffer"], buffer_string);
            }
            //Create the new items
            for(var i=instance_number(obj_item);i&lt;count;i++){
                var powerX = buffer_read(async_load[? "buffer"], buffer_f32);
                var powerY = buffer_read(async_load[? "buffer"], buffer_f32);
                var item = instance_create(powerX, powerY, obj_item);
                item.phy_speed_y = buffer_read(async_load[? "buffer"], buffer_f32);
                item.trap = buffer_read(async_load[? "buffer"], buffer_bool);
                item.station = buffer_read(async_load[? "buffer"], buffer_u8);
                item.type = buffer_read(async_load[? "buffer"], buffer_string);
            }
            //Destroy the old items
            for(var i=count;i&lt;instance_number(obj_item);i++)
                with(instance_find(obj_item, i))
                    instance_destroy();
        
            //Handle getting ball info
            count = buffer_read(async_load[? "buffer"], buffer_u16);
            //Update current balls
            for(var i=0;i&lt;instance_number(obj_ball) &amp;&amp; i&lt;count;i++){
                var ball = instance_find(obj_ball, i);
                ball.newX = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.newY = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.phy_speed_x = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.phy_speed_y = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.damage = buffer_read(async_load[? "buffer"], buffer_u8);
            }
            //Create the new balls
            for(var i=instance_number(obj_ball);i&lt;count;i++){
                var ballX = buffer_read(async_load[? "buffer"], buffer_f32);
                var ballY = buffer_read(async_load[? "buffer"], buffer_f32);
                var ball = instance_create(ballX, ballY, obj_ball);
                ball.phy_speed_x = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.phy_speed_y = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.damage = buffer_read(async_load[? "buffer"], buffer_u8);
            }
            //Destroy the old balls
            for(var i=count;i&lt;instance_number(obj_ball);i++)
                with(instance_find(obj_ball, i))
                    instance_destroy();
                    
            //Handle getting special ball info
            count = buffer_read(async_load[? "buffer"], buffer_u16);
            //Update current balls
            for(var i=0;i&lt;instance_number(obj_ballSpecial) &amp;&amp; i&lt;count;i++){
                var ball = instance_find(obj_ballSpecial, i);
                ball.newX = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.newY = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.phy_speed_x = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.phy_speed_y = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.damage = buffer_read(async_load[? "buffer"], buffer_u8);
                ball.type = buffer_read(async_load[? "buffer"], buffer_string);
            }
            //Create the new special balls
            for(var i=instance_number(obj_ballSpecial);i&lt;count;i++){
                var ballX = buffer_read(async_load[? "buffer"], buffer_f32);
                var ballY = buffer_read(async_load[? "buffer"], buffer_f32);
                var ball = instance_create(ballX, ballY, obj_ballSpecial);
                ball.phy_speed_x = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.phy_speed_y = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.damage = buffer_read(async_load[? "buffer"], buffer_u8);
                ball.type = buffer_read(async_load[? "buffer"], buffer_string);
            }
            //Destroy the old special balls
            for(var i=count;i&lt;instance_number(obj_ballSpecial);i++)
                with(instance_find(obj_ballSpecial, i))
                    instance_destroy();
            
            //Handle getting turret ball info
            count = buffer_read(async_load[? "buffer"], buffer_u16);
            //Update current balls
            for(var i=0;i&lt;instance_number(obj_ballTurret) &amp;&amp; i&lt;count;i++){
                var ball = instance_find(obj_ballTurret, i);
                ball.newX = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.newY = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.phy_speed_x = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.phy_speed_y = buffer_read(async_load[? "buffer"], buffer_f32);
            }
            //Create the new turret balls
            for(var i=instance_number(obj_ballTurret);i&lt;count;i++){
                var ballX = buffer_read(async_load[? "buffer"], buffer_f32);
                var ballY = buffer_read(async_load[? "buffer"], buffer_f32);
                var ball = instance_create(ballX, ballY, obj_ballTurret);
                ball.phy_speed_x = buffer_read(async_load[? "buffer"], buffer_f32);
                ball.phy_speed_y = buffer_read(async_load[? "buffer"], buffer_f32);
            }
            //Destroy the old turret balls
            for(var i=count;i&lt;instance_number(obj_ballTurret);i++)
                with(instance_find(obj_ballTurret, i))
                    instance_destroy();
            
            //Handle getting emp info
            count = buffer_read(async_load[? "buffer"], buffer_u16);
            //Update current emp
            for(var i=0;i&lt;instance_number(obj_emp) &amp;&amp; i&lt;count;i++){
                var instance = instance_find(obj_emp, i);
                instance.newX = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.newY = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.image_index = buffer_read(async_load[? "buffer"], buffer_f32);
            }
            //Create the new emp
            for(var i=instance_number(obj_emp);i&lt;count;i++){
                var instanceX = buffer_read(async_load[? "buffer"], buffer_f32);
                var instanceY = buffer_read(async_load[? "buffer"], buffer_f32);
                var instance = instance_create(instanceX, instanceY, obj_emp);
                instance.image_index = buffer_read(async_load[? "buffer"], buffer_f32);
            }
            //Destroy the old emp
            for(var i=count;i&lt;instance_number(obj_emp);i++)
                with(instance_find(obj_emp, i))
                    instance_destroy();
                    
            //Handle getting telepad info
            count = buffer_read(async_load[? "buffer"], buffer_u16);
            //Update current telepad
            for(var i=0;i&lt;instance_number(obj_telepad) &amp;&amp; i&lt;count;i++){
                var instance = instance_find(obj_telepad, i);
                instance.newX = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.newY = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.color = buffer_read(async_load[? "buffer"], buffer_u32);
            }
            //Create the new telepad
            for(var i=instance_number(obj_telepad);i&lt;count;i++){
                var instanceX = buffer_read(async_load[? "buffer"], buffer_f32);
                var instanceY = buffer_read(async_load[? "buffer"], buffer_f32);
                var instance = instance_create(instanceX, instanceY, obj_telepad);
                instance.color = buffer_read(async_load[? "buffer"], buffer_u32);
            }
            //Destroy the old telepad
            for(var i=count;i&lt;instance_number(obj_telepad);i++)
                with(instance_find(obj_telepad, i))
                    instance_destroy();
            
            //Handle getting trap info
            count = buffer_read(async_load[? "buffer"], buffer_u16);
            //Update current trap
            for(var i=0;i&lt;instance_number(obj_trap) &amp;&amp; i&lt;count;i++){
                var instance = instance_find(obj_trap, i);
                instance.newX = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.newY = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.phy_speed_x = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.phy_speed_y = buffer_read(async_load[? "buffer"], buffer_f32);
            }
            //Create the new trap
            for(var i=instance_number(obj_trap);i&lt;count;i++){
                var instanceX = buffer_read(async_load[? "buffer"], buffer_f32);
                var instanceY = buffer_read(async_load[? "buffer"], buffer_f32);
                var instance = instance_create(instanceX, instanceY, obj_trap);
                instance.phy_speed_x = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.phy_speed_y = buffer_read(async_load[? "buffer"], buffer_f32);
            }
            //Destroy the old trap
            for(var i=count;i&lt;instance_number(obj_trap);i++)
                with(instance_find(obj_trap, i))
                    instance_destroy();
            
            //Handle getting turret info
            count = buffer_read(async_load[? "buffer"], buffer_u16);
            //Update current turret
            for(var i=0;i&lt;instance_number(obj_turret) &amp;&amp; i&lt;count;i++){
                var instance = instance_find(obj_turret, i);
                instance.newX = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.newY = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.phy_speed_x = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.phy_speed_y = buffer_read(async_load[? "buffer"], buffer_f32);
            }
            //Create the new turret
            for(var i=instance_number(obj_turret);i&lt;count;i++){
                var instanceX = buffer_read(async_load[? "buffer"], buffer_f32);
                var instanceY = buffer_read(async_load[? "buffer"], buffer_f32);
                var instance = instance_create(instanceX, instanceY, obj_turret);
                instance.phy_speed_x = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.phy_speed_y = buffer_read(async_load[? "buffer"], buffer_f32);
            }
            //Destroy the old turret
            for(var i=count;i&lt;instance_number(obj_turret);i++)
                with(instance_find(obj_turret, i))
                    instance_destroy();
                    
            //Handle getting guard info
            count = buffer_read(async_load[? "buffer"], buffer_u16);
            //Update current guard
            for(var i=0;i&lt;instance_number(obj_guard) &amp;&amp; i&lt;count;i++){
                var instance = instance_find(obj_guard, i);
                instance.newX = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.newY = buffer_read(async_load[? "buffer"], buffer_f32);
            }
            //Create the new guard
            for(var i=instance_number(obj_guard);i&lt;count;i++){
                var instanceX = buffer_read(async_load[? "buffer"], buffer_f32);
                var instanceY = buffer_read(async_load[? "buffer"], buffer_f32);
                var instance = instance_create(instanceX, instanceY, obj_guard);
            }
            //Destroy the old guard
            for(var i=count;i&lt;instance_number(obj_guard);i++)
                with(instance_find(obj_guard, i))
                    instance_destroy();
            
            //Handle getting temp wall info
            count = buffer_read(async_load[? "buffer"], buffer_u16);
            //Update current temp wall
            for(var i=0;i&lt;instance_number(obj_tempWall) &amp;&amp; i&lt;count;i++){
                var instance = instance_find(obj_tempWall, i);
                instance.x = buffer_read(async_load[? "buffer"], buffer_f32);
                instance.y = buffer_read(async_load[? "buffer"], buffer_f32);
            }
            //Create the new temp wall
            for(var i=instance_number(obj_tempWall);i&lt;count;i++){
                var instanceX = buffer_read(async_load[? "buffer"], buffer_f32);
                var instanceY = buffer_read(async_load[? "buffer"], buffer_f32);
                var instance = instance_create(instanceX, instanceY, obj_tempWall);
            }
            //Destroy the old temp wall
            for(var i=count;i&lt;instance_number(obj_tempWall);i++)
                with(instance_find(obj_tempWall, i))
                    instance_destroy();
                    
            //Handle getting player info
            var numPlayers = buffer_read(async_load[? "buffer"], buffer_u8);
            var playerNum = 0;
            for(var i=0;i&lt;numPlayers;i++){
                var playerID = buffer_read(async_load[? "buffer"], buffer_u8);
                var player;
                var pX = buffer_read(async_load[? "buffer"], buffer_f32);
                var pY = buffer_read(async_load[? "buffer"], buffer_f32);
                if(playerID==clientNum+1){
                    player = instance_find(obj_playerClient, 0);
                    if(player==noone)
                        continue;
                    player.newX = pX;
                    player.newY = pY;
                }
                else if(playerNum&gt;=instance_number(obj_playerNetwork)){
                    player = instance_create(pX, pY, obj_playerNetwork);
                    playerNum++;
                }
                else{
                    player = instance_find(obj_playerNetwork, playerNum);
                    player.newX = pX;
                    player.newY = pY;
                    playerNum++;
                }
                player.phy_speed_x = buffer_read(async_load[? "buffer"], buffer_f32);
                player.phy_speed_y = buffer_read(async_load[? "buffer"], buffer_f32);
                player.hitPoints = buffer_read(async_load[? "buffer"], buffer_u8);
                player.fuel = buffer_read(async_load[? "buffer"], buffer_f32);
                player.ammo = buffer_read(async_load[? "buffer"], buffer_f32);
                player.items[OFFENSE] = buffer_read(async_load[? "buffer"], buffer_string);
                player.items[DEFENSE] = buffer_read(async_load[? "buffer"], buffer_string);
                player.items[UTILITY] = buffer_read(async_load[? "buffer"], buffer_string);
                player.items[TRAP] = buffer_read(async_load[? "buffer"], buffer_string);
                player.shield = buffer_read(async_load[? "buffer"], buffer_u8);
                player.body = buffer_read(async_load[? "buffer"], buffer_u8);
                player.reflex = buffer_read(async_load[? "buffer"], buffer_u8);
                player.invincible = buffer_read(async_load[? "buffer"], buffer_bool);
                player.num = playerID;
                if(ds_list_size(clientInfo)&gt;playerID){
                    var split = scr_splitString(clientInfo[|playerID], "&amp;");
                    player.name = split[0];
                    show_debug_message(player.name+":"+string(playerID));
                }
            }
            for(var i=instance_number(obj_playerNetwork);i&gt;numPlayers-1;i--)
                with(instance_find(obj_playerNetwork, i))
                    instance_destroy();
            for(var i=0;i&lt;ds_list_size(clientInfo);i++)
                show_debug_message(clientInfo[|i]);
            show_debug_message("---------------");
            break;
            
        case END_GAME:
            state = NONE;
            var winner = buffer_read(async_load[? "buffer"], buffer_string);
            show_message_async("Player "+winner+" wins!");
            instance_destroy();
            room_goto(rm_mainMenu);
            break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
